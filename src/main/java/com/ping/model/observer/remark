观察者模式

实例:
    微信公众号服务不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息

定义:
    在对象之间定义了一对多的依赖，其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息

角色：
    Subject（观察目标）：目标又称为主题，提供一系列方法来增加和删除观察者对象，同时它定义了通知方法notify()。目标类可以是接口，也可以是抽象类或具体类。
    ConcreteSubject（具体观察目标）：是Subject的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）

    Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法update()，因此又称为抽象观察者
    ConcreteObserver（具体观察者）：它实现了在抽象观察者Observer中定义的update()方法

优点:
    实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色
    在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者
    支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度
    满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便

缺点:
    如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间
    如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
    没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化
