原型模式

定义:
    通过克隆现有的实例来创建新的实例(序列化、反序列化，字节码复制)

实现:
    在java中由于Object类中有一个clone()方法，所以要使用原型模式只要实现Cloneable的接口就可以了
    Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法得到一个对象的复制

浅克隆：
    只克隆基本数据类型、String类型，而不复制它所引用的对象，也就是说如果被克隆的对象中，有对其他对象的引用，那么就只复制那个对象的引用，而不是重新复制一个新的对象
    在上面的例子中，Student对象中具有对Book的引用，那么在使用浅克隆时（使用Clone()方法），复制的s1的book和原来的book是同一个对象，所以s.getBook() ==s1.getBook() 返回 true

深克隆：
    除了浅度克隆要克隆的值外，还负责克隆引用类型的数据
    深克隆的方法有，反序列化，重写Clone()方法等。在上述例子中，就使用了序列化和反序列化的手段。由此，s.getBook() ==s1.getBook() 返回 false

序列化实现深度克隆
    把对象写到流里的过程是序列化(Serialization)过程,而把对象从流中读出来的过程则叫反序列化(Deserialization)过程
    在序列化一个对象时，应该先实现Serializable接口，然后把对象(实际是对象的拷贝)写到流里面，然后再从流里面反序列化出来，这样就重新创建了一个对象

    使用这个方法有一个前提，那就是要克隆的对象所引用的所有对象都应该是可序列化的，那么如果遇到不可序列化的对象时应该怎么办哪？
    这时就要用到transient关键字了（注意：transient只能修饰变量），被transient修饰的变量在序列化时不会被序列化。在上述的例子中，Student的age变量使用了transient关键字修饰，所以我们可以看到s.getAge()的值为12，而s2.getAge()的值为0（int类型默认值为0）

优点：
    向客户隐藏制造新实例的复杂性
    提供让客户能够产生未知类型对象的选项
    在某些环境下，复制对象比创建对象更加有效

缺点：
    对象的复制有时相当的复杂。特别是当一个类引用不支持序列化的间接对象，或者引用含有循环结构的时候

用途：
    在一个复杂的类层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型
