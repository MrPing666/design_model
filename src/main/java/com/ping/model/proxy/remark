代理模式的定义：
    由代理对象控制对原对象的引用,通俗的来讲代理模式就是我们生活中常见的中介

为什么要用代理模式:
    中介隔离作用
    开闭原则，增加功能

静态代理总结：
    优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展
    缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改

动态代理总结：
    生成代理类，并且实现被代理类

    动态代理减少了我们的开发任务和对业务接口的依赖，降低了耦合度,但是它始终无法摆脱仅支持interface代理的桎梏
    那些动态生成的代理类有一个共同的父类叫Proxy, Java的继承机制注定了动态代理类无法实现对class的动态代理，原因是多继承在Java中本质上就行不通

CGLIB代理总结：
    生成被代理对象子类，子类引用指向父类

    CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多
    所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些,同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理


满足代理模式应用场景的三个条件:
    二个角色--执行者、被代理对象
    注重过程--被代理对象没时间做或不想做、不专业
    执行者持有被代理对象的引用

代理模式总结:
    字节码重组---生成代理对象、编译class文件、加载进JVM

AOP(声明式事务)
    事务注解(是否开启事务)-- 事务开启(方法前) - 调用service - 事务提交或事务回滚(方法后) - 事务关闭

